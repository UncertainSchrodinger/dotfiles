# This file has been auto-generated by i3-config-wizard(1).
# It will not be overwritten, so edit it as you like.
#
# Should you change your keyboard layout some time, delete
# this file and re-run i3-config-wizard(1).
#

# i3 config file (v4)
# Please see https://i3wm.org/docs/userguide.html for a complete reference!
set $mod Mod4

# Font for window titles. Will also be used by the bar unless a different font
# is used in the bar {} block below.
font pango: Fira Mono 10

# Gaps
gaps outer 5px
gaps inner 15px

# Height of polybar is 37 + 8
gaps top 40px

# Always show marks
show_marks yes

# Don't let mouse hover change focus
focus_follows_mouse no

# The combination of xss-lock, nm-applet and pactl is a popular choice, so
# they are included here as an example. Modify as you see fit.

# xss-lock grabs a logind suspend inhibit lock and will use i3lock to lock the
# screen before suspend. Use loginctl lock-session to lock your screen.
# exec --no-startup-id xss-lock --transfer-sleep-lock -- i3lock --nofork

# NetworkManager is the most popular way to manage wireless networks on Linux,
# and nm-applet is a desktop environment-independent system tray GUI for it.
# exec --no-startup-id nm-applet

# Use pactl to adjust volume in PulseAudio.
# set $refresh_i3status killall -SIGUSR1 i3status
# bindsym XF86AudioRaiseVolume exec --no-startup-id pactl set-sink-volume @DEFAULT_SINK@ +10% && $refresh_i3status
# bindsym XF86AudioLowerVolume exec --no-startup-id pactl set-sink-volume @DEFAULT_SINK@ -10% && $refresh_i3status
# bindsym XF86AudioMute exec --no-startup-id pactl set-sink-mute @DEFAULT_SINK@ toggle && $refresh_i3status
# bindsym XF86AudioMicMute exec --no-startup-id pactl set-source-mute @DEFAULT_SOURCE@ toggle && $refresh_i3status

# Use Mouse+$mod to drag floating windows to their wanted position
floating_modifier $mod

# app shortcuts

# Terminal
bindsym $mod+Return exec i3-sensible-terminal

# kill focused window
bindsym $mod+Shift+q kill

# start rofi (a program launcher)
# similar binding as in mac. Also check the rofi configuration,
# pressing mod+space again closes it.
bindsym $mod+space exec --no-startup-id rofi -show run

# change focus like in vim
bindsym $mod+h focus left
bindsym $mod+j focus down
bindsym $mod+k focus up
bindsym $mod+l focus right

# move focused window
bindsym $mod+Shift+h move left
bindsym $mod+Shift+j move down
bindsym $mod+Shift+k move up
bindsym $mod+Shift+l move right

# split in horizontal orientation
bindsym $mod+o split h

# split in vertical orientation
bindsym $mod+v split v

# enter fullscreen mode for the focused container
# and hide polybar while in full screen
bindsym $mod+f fullscreen toggle; exec --no-startup-id polybar-msg -p $(pgrep -u $UID -x polybar) cmd toggle show

# Take screenshots
bindsym $mod+Print exec flameshot gui -p ~/Images/Screenshots

# change container layout (stacked, tabbed, toggle split)
bindsym $mod+s layout stacking
bindsym $mod+w layout tabbed
bindsym $mod+e layout toggle split

# focus the parent container
#bindsym $mod+a focus parent

# focus the child container
#bindsym $mod+d focus child

# read 1 character and mark the current window with this character
bindsym $mod+m exec i3-input -F 'mark %s' -l 1 -P 'Mark: '

# read 1 character and go to the window with the character
bindsym $mod+g exec i3-input -F '[con_mark="%s"] focus' -l 1 -P 'Goto: '

# Define names for default workspaces for which we configure key bindings later on.
# We use variables to avoid repeating the names in multiple places.
set $ws-browser "1:  Browser"
set $ws-terminals "2:  Term"
set $ws-ide "3:  Tools"
set $ws-chat "4:  Chats"
set $ws-media "5:  Media"
set $ws-gaming "6:  Gaming"
set $ws-present "7: 󱠏 Present"

# switch to workspace
bindsym $mod+1 workspace $ws-browser
bindsym $mod+2 workspace $ws-terminals
bindsym $mod+3 workspace $ws-ide
bindsym $mod+4 workspace $ws-chat
bindsym $mod+5 workspace $ws-media
bindsym $mod+6 workspace $ws-gaming
bindsym $mod+7 workspace $ws-present

# move focused container to workspace
bindsym $mod+Shift+1 move container to workspace $ws-browser
bindsym $mod+Shift+2 move container to workspace $ws-terminals
bindsym $mod+Shift+3 move container to workspace $ws-ide
bindsym $mod+Shift+4 move container to workspace $ws-chat
bindsym $mod+Shift+5 move container to workspace $ws-media
bindsym $mod+Shift+6 move container to workspace $ws-gaming
bindsym $mod+Shift+7 move container to workspace $ws-present

# Keys
#exec_always xmodmap -e "clear lock" #disable caps lock switch
#exec_always xmodmap -e "keysym Caps_Lock = Escape" #set caps_lock as escape

set $bg-color            #8BE9FD
set $border-color        #8BE9FD
set $inactive-bg-color   #282A36
set $text-color          #8BE9FD
set $inactive-text-color #676E7D
set $urgent-bg-color     #FF6E67
set $urgent-text-color   #000000

## window decoration
# class                 title border        background         text                 indicator
client.focused          $border-color       $bg-color          $text-color          #FF46B0
client.unfocused        $inactive-bg-color  $inactive-bg-color $inactive-text-color #FF46B0
client.focused_inactive $inactive-bg-color  $inactive-bg-color $inactive-text-color #FF46B0
client.urgent           $urgent-bg-color    $urgent-bg-color   $urgent-text-color   #FF46B0

client.background       $bg-color

# Only enable borders when there's more than one window
smart_borders on

for_window [class=".*"] border pixel 4

# reload the configuration file
bindsym $mod+Shift+c reload

# restart i3 inplace (preserves your layout/session, can be used to upgrade i3)
bindsym $mod+Shift+r restart

# Modes
# Thanks to samsaffron for this stealable gem
mode "exit: [l]ogout, [r]eboot, [s]hutdown" {
  bindsym l exec i3-msg exit, mode "default"
  bindsym r exec systemctl reboot, mode "default"
  bindsym s exec systemctl poweroff, mode "default"
  bindsym Escape mode "default"
  bindsym Return mode "default"
}

bindsym $mod+x mode "exit: [l]ogout, [r]eboot, [s]hutdown"

exec_always --no-startup-id feh --bg-scale $HOME/Images/wallhaven-9mxz8k.jpg
exec_always --no-startup-id $HOME/.config/polybar/launch.sh
exec_always --no-startup-id $HOME/.local/bin/start-dunst.sh
exec_always --no-startup-id flameshot

# Startup apps
#
# I work on multiple projects and clients with range of technologies.
# At first I thought about having separate terminal windows opened
# during startup and then just work on those.
#
# But having tried it I don't think this works for nothing else than:
#
#  * taking pretty screenshots
#  * showing bunch of useless crap you don't need during development
#    * like who has top open 247, a decade of development and I still
#      don't need to see it all the time
#  * gateway drug to anime backgrounds and lofi music
#  * making sure having multiple splits in vim is hard every second
#    you open up a laptop and don't have a wide monitor
#
# With multiple terminal windows I'm in a workflow where terminals
# open automatically and I then need to populate them with whatever
# windows I need for the project. Some might have 4, some might have
# 10. Tmux already does this and I can save the layouts and just
# open them at will. Hence only one terminal window.
exec --no-startup-id alacritty --class term-main
assign [instance="term-main"] $ws-terminals

# Scratch terminal is the only exception to the one terminal workflow.
# When working on code one usually goes in to the loop read, code,
# open up the browser, then try something and go back to coding. Scratch
# terminal is perfect for this! I stole the idea from Sam Saffrons configs.
#
# An example being you're debugging some build, you browse the web for a
# solution and it's a missing library. Either you install the library in
# some development window and now your window output is 100 lines full of
# crap you don't want to see. Or you open bring back the scratch terminal
# install the software, hide the terminal and then go back to working on
# code.
#
# Sure you can search the terminal output for what you need, but this just
# removes the step completely.
exec --no-startup-id alacritty --class scratch-term
for_window [instance="scratch-term"] floating enable, move to scratchpad
bindsym $mod+p [instance="scratch-term"] scratchpad show

# Keepassxc should always be available. One might think having it in the
# scratchpad would be nice, which is true, but that completely breaks stuff like
# auto-complete and 'secret service integration'. In scratchpad you first have
# to make the app visible and then the automation will work, which is kind of
# fucking stupid - to enable automation please provide manual input.
#
# I don't know why the fuck I have to have assign and for_window for this to
# work. Too tired to figure out this shit now.
exec --no-startup-id keepassxc
assign [class="KeePassXC"] $ws-ide
for_window [class="KeePassXC"] move to workspace $ws-ide

exec --no-startup-id discord
assign [class="discord"] $ws-chat

# There's a bug(?) in Firefox where it does not respect the class setting
# when using the same profile. So starting two instances with different
# class but same profile will not work. Hence we force the default profile
# here and private later.
exec --no-startup-id firefox --class firefox-main -P default-release
assign [class="firefox-main"] $ws-browser

# Firefox in private mode in scratch window. Every time there's an issue
# with cookies during development I need this.
for_window [class="firefox-private"] floating enable, move to scratchpad
exec --no-startup-id firefox -private-window --class firefox-private -P private
bindsym $mod+i [class="firefox-private"] scratchpad show

# https://i3wm.org/docs/userguide.html#assign_workspace
exec --no-startup-id spotify
for_window [class="Spotify"] move to workspace $ws-media

exec --no-startup-id steam
assign [title="Steam" class="steam"] $ws-gaming
assign [title="Friends List" class="steam"] $ws-gaming

# TODO: Everything launched from Term workspace should be floating. I wonder if
#       that is possible?
# Start PoB fork as floating
for_window [class="path-of-building"] floating enable
for_window [class="pico8"] move to workspace $ws-ide

# Automatic marks
#
# Mark windows I often use so I don't have to jump around workspaces.
# This was one of the things I always hated in mac and other systems.
# You have a bunch of windows in different workspaces, you want to
# jump to the browser, you either:
#
#   * alt+tab through a ton of windows, which sucks because you don't
#     care about seeing 20 other windows
#   * Go to the workspace you know the window is in and hope
#     you didn't open anything there which might steal the focus.
#     Every time one has to make a mental effort of scanning what
#     is the focused window and is this what I want.
#
# Workspaces are just to organize visual clutter, they really
# serve no other purpose for me. So let's just mark the windows
# which are used the most often! For a quick recap they are as follows:
#
# j - main browser
# k - main terminal
# l - spotify
# ö - discord
#
# I tried mapping keys to their names, like browser is on b and so
# on. But this is just annoying to type, you won't look at the keys
# when you press them. This is not some widely used software but
# just stuff I use, so the keys don't have to make any sense. The
# only thing that matters is that they are easy to use. They do have
# some mapping, my workspaces are ordered the same as the keys are
# on the keyboard.
#
# We could use bindings for these as well! But for now I'm trying
# marks. Plus the workflow works similiar to vim where, go to mark
# mode, type the mark. Sort of like changing windows in vim with
# ctrl+w + motion.
#
# TODO: Could I have something which marks every window created
#       automatically. This would pretty much be easymotions
#       for windows/panes.
for_window [class="firefox-main"] mark "j"
for_window [instance="term-main"] mark "k"
for_window [class="discord"] mark "l"
for_window [class="Spotify"] mark "ö"
for_window [class="KeePassXC"] mark "u"
for_window [title="Steam" class="steam"] mark "o"
for_window [title="Friends List" class="steam"] mark "i"

for_window [class="firefox-main"] focus
